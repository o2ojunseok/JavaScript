### 재귀와 스택

- 큰 목표 작업 하나를 동일하면서 간단한 작업 여러 개로 나눌 수 있을 때 유용한 프로그래밍 패턴이다.
- 목표 작업을 간단한 동작 하나와 목표 작업을 변형한 작업으로 단순화시킬 수 있을 때도 재귀를 사용.
- 문제 해결을 하다 보면 함수에서 다른 함수를 호출해야 할 때가 있다. 이떄 함수가 자기 자신을 호출할 수도 있는데 이를 재귀라고 한다.

## 사고방식

- 납복적인 사고를 통한 방법 : for 루프

```Javascript
function pow(x, n) {
    let result = 1;

    // 반복문을 돌면서 x를 번 곱한다.
    for (let i = 0; i < n; i++) {
        result == x;
    }

    return result;
}

alert( pow(2,3)); // 8
```

- 재귀적인 사고를 통한 방법 : 작업을 단순화하고 자기 자신을 호출함

```Javascript
function pow (x,n) {
    if (n == 1) {
        return x;
    } dlse {
        return x = pow(x, n - 1);
    }
}
alert ( pow(2,3)); // 8
```

- 재귀를 이용한 예시가 반복문을 사용한 예씨와 어떤 부분에서 근본적인 차이가 있는지 유심히 봐보자!
- pow(x,n) 을 호출하면 아래와 같이 두 갈래로 나뉘어 코드가 실행된다.
  - pow(x,n) = if n == 1 = x
  - pow(x,n) = else = x \* pow(x, n - 1)
- n == 1 일때 : 모든 절차가 간단해진다. 명확한 결과값을 즉시 도출하므로 이를 재귀의 베이스 라고 한다. pow(x,1) 은 x 이다.
- n == 1 이 아닐 때 : pow(x,n)은 x _ pow(x, n -1)으로 표현할 수 있다. 수학식으론 x엔제곱 = x _ x엔제곱-1 로 표현할 수 있다. 이를 재귀 단계 라고 부른다. 여기선 목표작업 pow(x,n) 을 간단한 동작(x 곱하기)과 목표작업을 변형한 작업 (pow(x, n-1)) 으로 분할하였다. 재귀 단계는 n 이 1이 될 떄까지 계속 이어진다.
- 즉 pow 는 n == 1이 될 떄까지 재귀적으로 자신을 호출한다.

### 실행 컨텍스트와 스택

- 실행 중인 함수의 실행 절차에 대한 정보는 해당 함수의 실행 컨텍스트에 저장된다.
- 실행 컨텍스트는 함수 실행에 대한 세부 정보를 담고 있는 내부 데이터 구조이다. 제어 흐름의 현재 위치, 변수의 현재 값, this의 값 등 상세 내부 정보가 실행 컨텍스트에 저장된다.
- 함수 호출 일 회당 하나의 실행 컨텍스트가 생성된다.
- 햄수 내부에 중첩 호출이 있을 때는 다음과 같은 절차가 수행된다.
  - 현재 함수의 실행이 일시 중지된다.
  - 중지된 함수와 연관된 실행 컨텍스트는 실행컨텍스트 스택 이라는 특별한 자료 구조에 저장된다.
  - 중첩 호출이 실행된다.
  - 중첩 호출 실행이 끝난 이후 실행 컨섹스트 스택에서 일단 중단한 함수의 실행컨텍스트를 꺼내오고, 중단한 함수의 실행을 다시 이어간다.

## 재귀적 순회

- 재귀는 재귀적 순회를 구현할 때 사용하면 좋다.

```Javascript
let company = {
    sales: [{
        name: 'John',
        salary: 1000
    }, {
        name: 'Alice',
        salary: 1600
    }],

    development: {
        sites: [{
            name: 'Peter',
            salary: 2000
        }, {
            name: 'Alex',
            salary: 1800
        }],

        internals: [{
            name: 'Jack',
            salary: 1300
        }]
    }
};
```

- 부서에는 여러 명의 직원이 있는데, 이를 배열로 표현할 수 있다. sales 부서와 John,Alice 라는 2명의 직원을 배열 요소로 표현
- 부서는 하위 부서를 가질 수 있다. development 부서는 sites와 internals 라는 두 개의 하위 부서를 가진다. 각 하위 부서에도 직원이 있다.
- 하위 부서가 커지면 더 작은 단위의 하위 부서로 쪼개질 가능성도 있다.
  - sites 부서는 미래에 siteA와 siteB로 나뉠 수 있다. 이렇게 나눠진 부서가 미래에 더 세분화될 수도 있다. 미래에 벌어질 일까진 나타내진 않았지만, 이런 가능성도 있다는걸 염두해야한다.
- 구조가 단순하지 않기 때문에 반복문을 사용해선 구하기 쉽지 않아보인다. 가장 먼저 떠오르는 생각은 company를 대상으로 동작하는 for 반복문을 만들고 한 단계 아래의 부서에 중첩 반복문을 돌리는 것이다. 그런데 이렇게 하면 sites 같은 두 단계 아래의 부서에 속한 임직원의 급여를 뽑아낼 때 또 다른 중첩 반복문이 필요하다. 시 단계 아래의 부서가 미래에 만들어진다고 가정하면 또 다른 중첩 반복문이 필요하다. 얼마만큼의 깊이까지 중첩 반복문을 만들 수 있을까? 객체를 순회하는 중첩 반복문의 깊이가 3~4개가 되는 순간 코드는 지저분해 진다.
- 재귀를 이용해보자
- 임직원 배열을 가진 단순한 부서 : 간단한 경우로 재귀의 베이스가 된다.
- N 개의 하위 부서가 있는 객체 : 각 하위 부서에 속한 임직원의 급여 합계를 얻기 위해 N 번의 재귀 호출을 하고, 최종적으로 부서의 깊이에 따라 더 작은 작업으로 쪼갤 수 있는데, 결국 마지막엔 첫 번째 경우가 된다.

```Javascript
let company = { //동일한 객체(간결성을 위해 약간 압축
    sales: [{name: 'John', salary: 1000}, {name: 'Alice', salary: 1600}],
    development: {
        sites: [{name: 'Peter', salary: 2000}, {name: 'Alex', salary: 1000}],
        internals: [{name: 'Jack', salary: 1300}]
    }
};

// 급여 함계를 구해주는 함수
function sumSalaries(department) {
    if (Array.isArray(department)) {// 첫번째 경우
        return department.reduce((prev, current) => prev + current.salary, 0); // 배열의 요소를 합함
    } else { //두번째
        let sum = 0;
        for (let subdep of Object.values(department)) {
            sum += sumSalaries(subdep); // 재귀 호출로 각 하위 부서 임직원의 급여 총합을 구함
        }
        return sum;
    }
}

alert(sumSalaries(company)); // 7700
```

- 하위 부서의 깊이와 상관없이 원하는 값을 구할 수 있게 되었다.
- 함수 내부에선 앞서 학습한 두 문법을 사용하고 있는 것도 확인하자.
  - 배열과 메서드 챕터에서 학습한 메서드 arr.reduce는 배열의 합을 계산해준다.
  - for(val of Object.values(obj)) 에서 쓰인 Object.values 는 프로퍼티의 값이 담긴 배열을 반환한다.

### 재귀적 구조

- 재귀적으로 정의된 자료구조인 재귀적 자료 구조는 자기 자신의 일부를 복제하는 형태의 자료 구조이다.
- 몇몇 상황에서는 배열 대신 연결 리스트를 사용하면 더 좋은 경우가 있다.

### 연결 리스트

- 객체를 정렬하여 어딘가에 저장하고 싶다고 가정해 보자.
- 가장 먼저 떠오르는 자료 구조는 이마 배열이다.

```Javascript
let arr = [obj1, obj2, obj3];
```

- 하지만 배열은 요소 삭제와 삽입에 들어가는 비용이 많이 든다는 문제가 있다. arr.unshift(obj) 연산을 수행하려면 새로운 obj 를 위한 공간을 만들기 위해 모든 요소의 번호를 다시 매겨야 한다. 배열이 커지면 연산 수행 시간이 더 걸리게 된다. arr.shift() 를 사용할 때에도 마찬가지이다.
- 요소 전체의 번호를 다시 매기지 않아도 되는 조작은 배열 끝에 하는 연산인 arr.push/pop 뿐이다. 앞쪽 요소에 무언가를 할 때 배열은 이렇게 느리다.
- 빠르게 삽입 혹은 삭제를 해야할 때에는 배열 대신 연결리스트라 불리는 자료구조를 사용할 수 있다.
  - value
  - next: 다음 연결리스트 요소를 참조하는 프로퍼티. 다음요소가 없을 땐 null이 된다.

```Javascript
let list = {
    value: 1,
    next: {
        value: 2,
        next: {
            value: 3,
            next: {
                value: 4.
                next: null
            }
        }
    }
};
```

```Javascript
let list = { value: 1 };
list.next = { value: 2 };
list.next.next = { value: 3 };
list.next.next.next = { value: 4 };
list.next.next.next.next = null;
```

- 위 아래 동일한 연결리스트
- 이렇게 연결리스트를 만드니 객체가 여러개 있고, 각 객체엔 value와 이웃객체를 가르키는 프로퍼티인 next가 있는 게 보인다. 체인의 시작 객체는 변수 list에 저장되어 있다. 우리는 list에 next프로퍼티를 이용해 이어지는 객체 어디든 도달할 수 있다.
- 이전 요소를 참조하는 프로퍼티 prev를 추가해 이전 요소로 쉽게 이동하게 할 수 있다.
- 리스트의 마지막 요소를 참조하는 변수 tail를 추가할 수 있다. 다만 이때 주의할 점은 리스트 마지막에 요소를 추가하거나 삭제할 때 tail도 갱신해 주어야한다.
- 이외에도 요구사항에 따라 구조를 변경할 수 있다.
