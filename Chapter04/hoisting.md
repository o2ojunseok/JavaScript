### 호이스팅

- 함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 말한다.
- 함수 호이스팅은 함수를 호출하기 전에 반드시 함수를 선언해야 한다는 당연한 규칙을 무시한다.
- 스코프 내부 어디서든 변수 선언은 최상위에 선언된 것 처럼 행동

```javascript
// 함수 참조
console.dir(add); // f add(x,y)
console.dir(sub); // undifined

// 함수 호출
console.log(add(2, 5)); // 7
console.log(sub(2, 5)); // TypeError: sub is not a function

// 함수 선언문
function add(x, y) {
  return x + y;
}

// 함수 표현식
let sub = function (x, y) {
  return x - y;
};
```

- 위 예제와 같이 함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출할 수 있다. 그러나 함수 표현식으로 정의한 함수는 함수 표현식 이전에 호출할 수 없다.
- 이는 함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 시점이 다르기 때문이다.
- 모든 선언문이 그렇듯 함수 선언문도 코드가 한 줄씩 순차적으로 실행되는 시점인 런타임 이전에 자바스크립트 엔진에 의해 먼저 실행된다.
- 코드가 한 줄씩 순차적으로 실행되기 시작하는 런타임에는 이미 함수 객체가 생성되어 있고, 함수 이름과 동일한 식별자에 할당까지 환료된 상태다
- 따라서 함수 선언문 이전에 함수를 참조할 수 있으며 호출할 수도 있다.
- 함수호이스팅과 변수호이스팅은 미묘한 차이가 있으므로 주의할 것!!!
- 함수 표현식은 변수에 할당되는 값이 함수 리터럴인 문이다. 따라서 함수 표현식은 변수 선언문과 변수 할당문을 한 번에 기술한 축약 표현과 동일하게 동작한다.
- 변수 할당문의 값은 할당문이 실행되는 시점, 즉 런타임에 평가되므로 함수 표현식의 함수 리터럴도 할당문이 실행되는 시점에 평가되어 함수 객체가 된다.
- 따라서 함수 표현식으로 함수를 정의하면 함수 호이스팅이 발생하는 것이 아니라 변수 호이스팅이 발생한다.

### Temporal Dead Zone

- 이 영역 안에 변수들은 사용할 수 없다.
- let,const는 TDZ의 영향을 받는다.

### 변수의 생성과정

- 선언 및 초기화 단계
  - var
    - 선언과 초기화가 동시에 된다.
    - 할당전에 초기화 하면 undefined
  - let
    - 선언 단계와 초기화 단계가 분리되어서 진행.
    - 초기화 단계는 실제코드에 도달했을 때 발생
  - const
    - 선언과 할당이 동시에 된다.
